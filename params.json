{
  "name": "websocket-non-blocking-cpp",
  "tagline": "websocket non-blocking server implementation in C++",
  "body": "# Websocket non-blocking server library\r\n\r\n[![Build Status](https://travis-ci.org/akinaru/websocket-non-blocking.svg?branch=master)](https://travis-ci.org/akinaru/websocket-non-blocking)\r\n[![License](http://img.shields.io/:license-mit-blue.svg)](LICENSE.md)\r\n\r\nhttp://akinaru.github.io/websocket-non-blocking/\r\n\r\nC++ websocket non-blocking server library for Qt4/Qt5\r\n\r\n## Usage\r\n\r\nStart websocket server :\r\n```\r\nWebsocketServer server;\r\n\r\nbool success = server.listen(QHostAddress(\"127.0.0.1\"), 8443);\r\n```\r\n\r\nStop websocket server :\r\n```\r\nserver.close();\r\n```\r\n\r\n## Integrate in your project\r\n\r\n* from git submodule\r\n\r\n```\r\ngit submodule add git://github.com/akinaru/websocket-non-blocking.git\r\n```\r\n\r\nand in your `project.pro` :\r\n\r\n```\r\nTEMPLATE = subdirs\r\nSUBDIRS = websocket-non-blocking your-app\r\nyour-app.depends = websocket-non-blocking\r\n```\r\n\r\nwith in `your-app.pro` :\r\n\r\n```\r\nTARGET = your-app\r\nSOURCES = main.cpp\r\nINCLUDEPATH += $$PWD/../websocket-non-blocking/libwebsocket/release\r\nLIBS += -L$$PWD/../websocket-non-blocking/libwebsocket/release -lwebsocket\r\nDEPENDPATH += $$PWD/../websocket-non-blocking/libwebsocket/release\r\n```\r\n\r\n## Monitor clients\r\n\r\nBuild your own client monitoring class that inherits `IClientEventListener` : \r\n\r\n```\r\nclass ClientSocketHandler :  public IClientEventListener\r\n{\r\npublic:\r\n\r\n    ClientSocketHandler();\r\n\r\n    ~ClientSocketHandler();\r\n\r\n    void onClientClose(IWebsocketClient &client);\r\n\r\n    void onClientConnection(IWebsocketClient &client);\r\n\r\n    void onMessageReceivedFromClient(IWebsocketClient &client, std::string message);\r\n};\r\n```\r\n\r\nAdd listener to server instance : \r\n\r\n```\r\n#include \"ClientSockethandler.h\"\r\n\r\n....\r\n\r\nClientSocketHandler *clientHandler = new ClientSocketHandler();\r\n\r\nserver.addClientEventListener(clientHandler);\r\n```\r\n\r\nIn this `ClientSocketHandler` you have 3 callbacks that will notify you on client connection change and arrival of client messages :\r\n\r\n* `void onClientClose(IWebsocketClient &client);` notify when client socket close\r\n* `void onClientConnection(IWebsocketClient &client);` notify when client socket connect to server\r\n* `void onMessageReceivedFromClient(IWebsocketClient &client,std::string message);` notify when a socket client send a message to you\r\n\r\nYou can send a message back with `IWebsocketClient` sent from the same callback with `sendMessage(std::string textToSend)` method :\r\n\r\n```\r\nvoid ClientSocketHandler::onMessageReceivedFromClient(IWebsocketClient &client,string message)\r\n{\r\n    cout << \"Client socket message received : \" << message.data() << endl;\r\n\r\n    client.sendMessage(\"OK I received your message !\");\r\n}\r\n```\r\n\r\nCheck the client monitoring example [here](./libwebsocket-test/ClientSocketHandler.cpp)\r\n\r\n## SSL secured websocket server\r\n\r\n```\r\nWebsocketServer server;\r\n\r\nserver.setSSL(true); // set SSL to true (default is false)\r\n```\r\n\r\nThen you set your public/private/ca certificates separately with respective methods : \r\n\r\n```\r\nserver.setPublicCert(SslHandler::retrieveCertFromFile(PUBLIC_CERT));\r\nserver.setPrivateCert(SslHandler::retrieveKeyCertFile(PRIVATE_CERT,PRIVATE_CERT_PASS));\r\nserver.setCaCert(SslHandler::retrieveveCaCertListFromFile(CA_CERTS));\r\n```\r\n\r\nYou can use static method from [`SslHandler`](./libwebsocket-test/SslHandler.cpp) :\r\n\r\n* public cert must be a QSslCertificate : `SslHandler::retrieveCertFromFile(char * filepath)`\r\n* private cert must be a QSslKey : `SslHandler::retrieveKeyCertFile(char * filepath,char * passKey)`\r\n* CA cert must be a QList of QSslCertificate : `SslHandler::retrieveveCaCertListFromFile(char * filepath)`\r\n\r\nEventually add event listener as described above and start websocket server : \r\n\r\n```\r\nserver.addClientEventListener(clientHandler);\r\n\r\nbool success = server.listen(QHostAddress(\"127.0.0.1\"), 8443);\r\n```\r\n\r\n## Troubleshooting SSL errors with local browser JS client\r\n\r\n>Bad certificate | Unknown CA errors\r\n\r\nThis could mean you didn't import your not-trusted-CA certificate into your browser.\r\n\r\n>The remote host closed the connection\r\n\r\nJust load your URL with \"https\" : https://127.0.0.1:8443 . Browser will prompt you to accept the certificates and it will probably solve your connection error.\r\n\r\n\r\n## Debugging SSL connection error\r\n\r\nuse openssl command line tool to debug ssl connection : \r\n\r\n```\r\nopenssl s_client -connect 127.0.0.1:8443\r\n```\r\n\r\n## Server-Client key/cert generation\r\n\r\nSample certs are in [libwesocket-test/certs](./libwesocket-test/certs) folder, you will find server,client and ca cert build with easy-rsa :\r\n\r\nhttps://github.com/OpenVPN/easy-rsa\r\n\r\nWith last release of easy-rsa, you can build your own key with the following : \r\n\r\n* `./build-ca` : generate a new CA for you\r\n* `./build-server-full myServer` : will build for you public cert and private cert signed with CA for server\r\n* `./build-client-full myClient` : will build for you public cert and private cert signed with CA for client\r\n\r\n## Build library & examples\r\n\r\n```\r\nqmake\r\nmake\r\n```\r\n\r\n## Run examples\r\n\r\nOpen a websocket on port 8443 :\r\n\r\n```\r\n./libwebsocket-test/release/libwebsocket-test 127.0.0.1 8443\r\n```\r\n\r\nOpen Javascript clients located in [client-test/js](./client-test/js) :\r\n\r\n<hr/>\r\n\r\n![client side](./img/clientSide.png)\r\n\r\n<hr/>\r\n\r\n![server side](./img//serverSide.png)\r\n\r\n## Valgrind checking\r\n\r\n```\r\ncd libwebsocket-test/release\r\n\r\nvalgrind --tool=memcheck --leak-check=full --suppressions=../../memcheck.suppress ./libwebsocket-test <ip> <port>\r\n\r\n```\r\n\r\n## Compatibility\r\n\r\n* Qt4\r\n* Qt5\r\n\r\n## Specification\r\n\r\n* https://tools.ietf.org/html/rfc6455",
  "google": "UA-62569105-1",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}